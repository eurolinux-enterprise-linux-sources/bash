diff --git a/lib/readline/input.c b/lib/readline/input.c
index b5876da..621525f 100644
--- a/lib/readline/input.c
+++ b/lib/readline/input.c
@@ -45,6 +45,8 @@
 #  include "ansi_stdlib.h"
 #endif /* HAVE_STDLIB_H */
 
+#include <signal.h>
+
 #include "posixselect.h"
 
 #if defined (FIONREAD_IN_SYS_IOCTL)
@@ -503,11 +505,26 @@ rl_getc (stream)
 #undef X_EWOULDBLOCK
 #undef X_EAGAIN
 
-      /* If the error that we received was SIGINT, then try again,
-	 this is simply an interrupted system call to read ().
-	 Otherwise, some error ocurred, also signifying EOF. */
+      /* If the error that we received was EINTR, then try again,
+	 this is simply an interrupted system call to read ().  We allow
+	 the read to be interrupted if we caught SIGHUP or SIGTERM (but
+	 not SIGINT; let the signal handler deal with that), but if the
+	 application sets an event hook, call it for other signals.
+	 Otherwise (not EINTR), some error occurred, also signifying EOF. */
       if (errno != EINTR)
 	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
+      else if (_rl_caught_signal == SIGHUP || _rl_caught_signal == SIGTERM)
+	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
+      /* keyboard-generated signals of interest */
+      else if (_rl_caught_signal == SIGINT || _rl_caught_signal == SIGQUIT)
+        RL_CHECK_SIGNALS ();
+      /* non-keyboard-generated signals of interest */
+      else if (_rl_caught_signal == SIGALRM
+#if defined (SIGVTALRM)
+		|| _rl_caught_signal == SIGVTALRM
+#endif
+	      )
+        RL_CHECK_SIGNALS ();
     }
 }
 
diff --git a/lib/readline/signals.c b/lib/readline/signals.c
index 4fbc019..98c6e72 100644
--- a/lib/readline/signals.c
+++ b/lib/readline/signals.c
@@ -87,7 +87,7 @@ static RETSIGTYPE _rl_handle_signal PARAMS((int));
 /* Exported variables for use by applications. */
 
 /* If non-zero, readline will install its own signal handlers for
-   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
+   SIGINT, SIGTERM, SIGHUP, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
 int rl_catch_signals = 1;
 
 /* If non-zero, readline will install a signal handler for SIGWINCH. */
@@ -118,7 +118,7 @@ static int sigwinch_set_flag;
 /*								    */
 /* **************************************************************** */
 
-static sighandler_cxt old_int, old_term, old_alrm, old_quit;
+static sighandler_cxt old_int, old_term, old_hup, old_alrm, old_quit;
 #if defined (SIGTSTP)
 static sighandler_cxt old_tstp, old_ttou, old_ttin;
 #endif
@@ -188,6 +188,7 @@ _rl_handle_signal (sig)
       /* FALLTHROUGH */
 
     case SIGTERM:
+    case SIGHUP:
 #if defined (SIGTSTP)
     case SIGTSTP:
     case SIGTTOU:
@@ -348,6 +349,7 @@ rl_set_signals ()
 
       sigaddset (&bset, SIGINT);
       sigaddset (&bset, SIGTERM);
+      sigaddset (&bset, SIGHUP);
 #if defined (SIGQUIT)
       sigaddset (&bset, SIGQUIT);
 #endif
@@ -376,6 +378,7 @@ rl_set_signals ()
 
       rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
       rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
+      rl_maybe_set_sighandler (SIGHUP, rl_signal_handler, &old_hup);
 #if defined (SIGQUIT)
       rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
 #endif
@@ -435,6 +438,7 @@ rl_clear_signals ()
 
       rl_sigaction (SIGINT, &old_int, &dummy);
       rl_sigaction (SIGTERM, &old_term, &dummy);
+      rl_sigaction (SIGHUP, &old_hup, &dummy);
 #if defined (SIGQUIT)
       rl_sigaction (SIGQUIT, &old_quit, &dummy);
 #endif
-- 
2.7.4

